## 6.1 Ruby on Rails：データベース設計、多対多の関連付け

ここからは、ECサイトアプリケーションの開発を例に各実装を解説していきます。
例題で各実装について解説し、問題を解くことによりECサイトが少しずつ完成していきます。  
まず、この章では、ECサイトのデータベース設計の解説を行います。
設計のために、ActiveRecord、データベース設計の基礎、多対多の関連付けについて簡単に説明します。

### 6.1.1 ActiveRecordとは

ActiveRecordとは、Railsに付属する、重要なライブラリの1つで、MVCのM(モデル)に相当します。  
ActiveRecordは、ORM (オブジェクトリレーショナルマッピング) で実装されています。
ORMとは、簡潔に説明すると、アプリケーションが持つオブジェクトとリレーショナルデータベース(RDBMS)を繋ぐプログラミング技法です。  
ActiveRecordはデータベースのテーブルをRubyのオブジェクトとしてモデル化することができます。これにより、データベース操作をオブジェクト指向の方法で行うことができます。  
また、ActiveRecordを使用することで、データベースのテーブル間の関連性を簡単に表現し、関連するデータの取得や保存を容易に行うことができます。  
さらに、ActiveRecordではデータの検証やバリデーションのルールをモデル内に定義することができます。これにより、不正なデータがデータベースに保存されることを防ぐことができます。  
ActiveRecordでは、下記の仕組みが特に重要となっています。

- モデルとそのデータを表す仕組み
- モデル間の関連性を表す仕組み
- 関連するモデルを通した階層の継承を表す仕組み
- DBに保存する前に検証する仕組み
- オブジェクト指向の手法でDB操作を実行する仕組み

データベースを操作するにはデータベースの言語が必要になりますが、Active RecordによってRubyを用いてデータベースの操作できます。  
例えば、データベースから「太郎」さんを取得したい場合、SQLでは以下のように書きます。
```sql
SELECT * FROM users WHERE name LIKE '%太郎%';
```
それをActiveRecordを使用して取得する場合は
```rb
User.where("name LIKE ?", "%太郎%")
```
このように直感的に書くことができます。


### 6.1.2 データベース設計の基礎

データベース設計はとても大事で難しい部分もあります。それだけで本が1冊書けるぐらいです。ここでは詳しく解説しませんが、データベースの構成次第で、あとの機能の実装がやりにくかったり複雑になってしまうので、くれぐれも注意してください。できるかぎり、サイトで扱うもの、関連のある人、サイトの使われ方などを具体的にイメージしながら考えていきましょう。  

今回はデータベース設計で決めることは次の4つのことを意識しましょう。

1. アプリで扱うデータをモレなく書き出す  
2. データの正規化（グループ分け）をする  
3. 各データの型（データの種類）を決める  
4. 各データのフィールド名（アルファベット）を決める  

<br>

__【アプリで扱うデータをモレなく書き出す】__  

まずは何をしたいのかを考えましょう。  
目的が決まればどのような項目が必要なのかが明確になります。    
例えば、ECサイトの場合はどのようなテーブルが必要になるでしょうか考えてみましょう。  
次にカラムの洗い出しをしましょう。例えば、先ほどのECサイトに商品テーブルやユーザーテーブルがあったとします。そのときどのようなカラムが必要になるか考えましょう。  

1. 商品テーブル：  
  ・商品名  
  ・価格  
  ・カテゴリ  
  ・在庫数  
    など    
2. ユーザーテーブル：   
  ・ユーザー名  
  ・メールアドレス  
  ・パスワード  
  ・住所  
    など  

この他にも注文テーブルや注文詳細テーブル、カテゴリーテーブル、カートテーブルなどがあったりします。  

<br>

__【データの正規化（グループ分け）をする】__  

データベースにおける正規化は、データの重複を最小限に抑え、データの整合性を保ちながらデータベースの柔軟性、効率性、信頼性を向上させます。  
それではどのようにグループ分けしていくのかステップごとに見ていきましょう。  
ある学校の生徒情報のデータベースを作成していきます。  

生徒テーブル
| 出席番号 | 名前       | 性別 | 部活                   | クラス | 担任     | 
| -------- | ---------- | ---- | ---------------------- | ------ | -------- | 
| 1001     | 佐藤次郎   | 男   | 野球部                 | 1組    | 渡辺一郎 | 
| 2002     | 鈴木健太   | 男   | サッカー部             | 2組    | 高橋恵   | 
| 1003     | 田中太郎   | 男   | やきゅう部<br>吹奏楽部 | 1組    | 渡辺一郎 | 
| 1004     | 中田さやか | 女   | テニス部<br>吹奏楽部   | 1組    | 渡辺一郎 | 
| 2005     | 山田花子   | 女   | サッカー部             | 2組    | 高橋恵   | 

部活カラムを見てください。  
田中太郎さんと中田さやかさんは部活を掛け持ちしています。  
まずはこの掛け持ちしている部活を2つに分けてレコードを作ってあげましょう。  

生徒テーブル
| 出席番号 | 名前       | 性別 | 部活       | クラス | 担任     | 
| -------- | ---------- | ---- | ---------- | ------ | -------- | 
| 1001     | 佐藤次郎   | 男   | 野球部     | 1組    | 渡辺一郎 | 
| 2002     | 鈴木健太   | 男   | サッカー部 | 2組    | 高橋恵   | 
| 1003     | 田中太郎   | 男   | やきゅう部 | 1組    | 渡辺一郎 | 
| 1003     | 田中太郎   | 男   | 吹奏楽部   | 1組    | 渡辺一郎 | 
| 1004     | 中田さやか | 女   | テニス部   | 1組    | 渡辺一郎 | 
| 1004     | 中田さやか | 女   | 吹奏楽部   | 1組    | 渡辺一郎 | 
| 2005     | 山田花子   | 女   | サッカー部 | 2組    | 高橋恵   | 

このように各列は単一の値のみを保持するようにしましょう。
次は主キーに該当するものを分けましょう。  
主キー(Primary Key)は、データベースのテーブル内の各レコードを一意に識別するための特定の列または列の組み合わせです。
今回主キーとそれに従属する組み合わせを探してグループに分けてみましょう。

生徒テーブル
| 出席番号 | 名前       | 性別 | 部活       | クラス | 
| -------- | ---------- | ---- | ---------- | ------ | 
| 1001     | 佐藤次郎   | 男   | 野球部     | 1組    | 
| 2002     | 鈴木健太   | 男   | サッカー部 | 2組    | 
| 1003     | 田中太郎   | 男   | やきゅう部 | 1組    | 
| 1003     | 田中太郎   | 男   | 吹奏楽部   | 1組    | 
| 1004     | 中田さやか | 女   | テニス部   | 1組    | 
| 1004     | 中田さやか | 女   | 吹奏楽部   | 1組    | 
| 2005     | 山田花子   | 女   | サッカー部 | 2組    | 

担任テーブル
| クラス | 担任     | 
| ------ | -------- | 
| 1組    | 渡辺一郎 | 
| 2組    | 高橋恵   | 

例えば1組の担任が変わったときに生徒の担任カラムを全て変えないといけませんが、このように分けることによって担任テーブルを変えるだけですみます。  

では、もう少し細かく分けてあげましょう。  
部活を見てみると野球部とやきゅう部があります。入力したデータが違うだけで別の部活になってしまいます。  
これもグループに分けてあげましょう。  

部活テーブル
| 部活ID | 部活名     | 
| ------ | ---------- | 
| 1      | 野球部     | 
| 2      | サッカー部 | 
| 3      | 吹奏楽部   | 
| 4      | テニス部   | 

一意にするために部活にIDを付けました。  
生徒テーブルや担任テーブルも一意にするために主キーとなるIDを付けてみましょう。
では、どのように対応しているか確認してみます。  

生徒テーブル
| ID(主キー) | 出席番号 | 名前       | 性別 | 部活ID | クラスID | 
| ---------- | -------- | ---------- | ---- | ------ | -------- | 
| 1          | 1001     | 佐藤次郎   | 男   | 1      | 1        | 
| 2          | 2002     | 鈴木健太   | 男   | 2      | 2        | 
| 3          | 1003     | 田中太郎   | 男   | 1      | 1        | 
| 4          | 1003     | 田中太郎   | 男   | 3      | 1        | 
| 5          | 1004     | 中田さやか | 女   | 4      | 1        | 
| 6          | 1004     | 中田さやか | 女   | 3      | 1        | 
| 7          | 2005     | 山田花子   | 女   | 2      | 2        | 

担任テーブル
| ID(主キー) | クラス | 担任     | 
| ---------- | ------ | -------- | 
| 1          | 1組    | 渡辺一郎 | 
| 2          | 2組    | 高橋恵   | 

部活テーブル
| ID(主キー) | 部活名     | 
| ---------- | ---------- | 
| 1          | 野球部     | 
| 2          | サッカー部 | 
| 3          | 吹奏楽部   | 
| 4          | テニス部   | 

きれいにグループ分けできました。  
ですが、実は生徒テーブルでは問題点があります。  
それはこの後の多対多の関連付けで確認していきます。

性別のように、「男」、「女」、「その他」などの基となる数が少ない場合はテーブルを分割する必要はありませんが、拡張性を考えてテーブルを追加することもできます。  

性別テーブル
| ID(主キー) | 性別   | 
| ---------- | ------ | 
| 1          | 男     | 
| 2          | 女     | 
| 3          | その他 | 

このように作成した場合、新たに追加が必要な時は4、5、6...といったように拡張できます。  
必要に応じてどのようにグループ分けするか考えてみましょう。

<br>

__【各データの型（データの種類）を決める】__  

各データがどのようなデータになるのかを考えてみましょう。  
以下はRailsにおける主要なデータ型です。これに先ほどの生徒テーブルを当てはめてみましょう。

1. 文字列型(String)：文字列を表すデータ型です。ActiveRecordでは`string`または`varchar`として表されます。
2. 整数型(Integer)：整数を表すデータ型です。ActiveRecordでは`integer`として表されます。
3. 浮動小数点型(Float)：浮動小数点数を表すデータ型です。ActiveRecordでは`float`として表されます。
4. 真偽値型(Boolean)：真偽値を表すデータ型です。ActiveRecordでは`boolean`として表されます。
5. 日付型(Date/Time)：日付や時間を表すデータ型です。ActiveRecordでは`date`や`datetime`として表されます。
6. バイナリ型(Binary)：バイナリデータを表すデータ型です。ActiveRecordでは`binary`として表されます。
7. テキスト型(Text)：長いテキストを格納するためのデータ型です。ActiveRecordでは`text`として表されます。
8. JSON型(JSON)：JSON形式のデータを格納するためのデータ型です。ActiveRecordでは`json`として表されます。

<br>

__【各データのフィールド名（アルファベット）を決める】__  

各データのフィールド名を考えていきます。  
わかりやすく命名するように心がけましょう。  
スネークケースを用いて、単語の間にアンダースコア（_）を挿入して単語を区切ります。

生徒テーブル：  
主キー　：id  
出席番号：attendance_num  
名前　　：name  
性別　　：gender  
部活ID　：club_id  
クラスID：class_id  

担任テーブル：  
主キー：id  
クラス：class  
担任名：name  

部活テーブル：  
主キー：id  
部活名：name  

ここにあげたものは、必ずしも順番にする必要はありません。いろいろ考えていくうちに他に必要なデータが見えてきたり、「こっちの名前がこうなら、あっちの名前はこうしよう」 ということが出てきます。
サイトを利用する場面や利用する人のことを想像しながら、納得するまで考えます。可能であれば、他のプログラミング経験者の意見を聞くことをおすすめします。

### 6.1.3 多対多の関連付け

データベースの関連付けには`1対1`、`多対1`、`多対多`があります。それぞれがどのような関連付けをされているかを見ていきましょう。

- 1対1 (One-to-One):

例：各生徒は1つの学生証を持ち、1つの学生証は1人の生徒に紐づく。  
1. 生徒テーブル(students)：生徒の個人情報を保存  
2. 学生証テーブル(student_ids)：各生徒の学生証情報を保存  

<br>

- 多対1 (Many-to-One):

例：1つの学校が複数の教室を持っている。  
1. 学校テーブル(schools)：教室を複数持っている  
2. 教室テーブル(classrooms)：学校に属する  

<br>

- 多対多 (Many-to-Many):

例: 1つの部活には複数の生徒が所属し、1人の生徒は複数の部活に参加することができる。  
1. 部活テーブル(clubs)：複数の生徒が所属している  
2. 生徒テーブル(students)：複数の部活に所属できる  
3. 中間テーブル(club_students) - 部活と生徒の関係を保持  

<br>

まず、多対多の関連付けとは、お互いのテーブルのレコード同士が複数の相手側レコードと関連付けられる関係の事です。  

多対多の関連付けには中間テーブルというものが出てきました。 
中間テーブル(第3のモデル)は、多対多の関係を持つ2つのテーブル間の関係を表現するために必要です。これにより、関連するデータを効果的に管理し、操作することができます。  

先ほどの生徒と部活の関係を見てみましょう。  
生徒A、生徒B、生徒Cが部活A、部活Bのそれぞれもしくはいずれかに入部しています。  

生徒テーブル
| ID  | 生徒  | 部活ID_1 | 部活ID_2 | 
| --- | ----- | -------- | -------- | 
| 1   | 生徒A | 1        | 2        | 
| 2   | 生徒B | 1        | null     | 
| 3   | 生徒C | 1        | 2        | 

部活テーブル
| ID  | 部活  | 生徒ID_1 | 生徒ID_2 | 生徒ID_3 | 
| --- | ----- | -------- | -------- | -------- | 
| 1   | 部活A | 1        | 2        | 3        | 
| 2   | 部活B | 1        | 3        | null     | 

1つのレコードにはデータが1つしか入れられないため、nullとなっているカラムが存在しています。  
このまま生徒がD、F、G...、部活がC、D、E...と増えていき入部する生徒が増えるとどうなるでしょうか。  

生徒テーブル
| ID  | 生徒  | 部活ID_1 | 部活ID_2 | 部活ID_3 | 
| --- | ----- | -------- | -------- | -------- | 
| 1   | 生徒A | 1        | 2        | 3        | 
| 2   | 生徒B | 1        | 3        | null     | 
| 3   | 生徒C | 1        | 2        | null     | 
| 4   | 生徒D | 1        | null     | null     | 

部活テーブル
| ID  | 部活  | 生徒ID_1 | 生徒ID_2 | 生徒ID_3 | 生徒ID_4 | 
| --- | ----- | -------- | -------- | -------- | -------- | 
| 1   | 部活A | 1        | 2        | 3        | 4        | 
| 2   | 部活B | 1        | 3        | null     | null     | 
| 3   | 部活C | 1        | 2        | null     | null     | 


カラムが増えてnullのデータも増えてしまいました。  
これに中間テーブルを足してみましょう。  

生徒テーブル
| ID  | 生徒  | 
| --- | ----- | 
| 1   | 生徒A | 
| 2   | 生徒B | 
| 3   | 生徒C | 
| 4   | 生徒D | 

部活テーブル
| ID  | 部活  | 
| --- | ----- | 
| 1   | 部活A | 
| 2   | 部活B | 
| 3   | 部活C | 

中間テーブル
| ID  | 生徒ID | 部活ID | 
| --- | ------ | ------ | 
| 1   | 1      | 1      | 
| 2   | 1      | 2      | 
| 3   | 1      | 3      | 
| 4   | 2      | 1      | 
| 5   | 2      | 3      | 
| 6   | 3      | 1      | 
| 7   | 3      | 2      | 
| 8   | 4      | 1      | 

このようにすることで不要なカラムやnullのデータが増えることを防ぎます。  
中間テーブルを使用することで、多対多の関係を効果的に表現することができます。  
また、中間テーブルを介して検索や操作を行うことで、関連するデータを効率的に取得および更新することができます。  

- has_many :throughでの関連付け  
2つのモデルの間に、互いのモデルのIDを保持している中間テーブルを作成して、紐付けします。
例えば、次の[3.3-例題]のように、先生と授業の関係を表します。実際にどのように実装するかは例題を見ていきましょう。


### 6.1.4 ActiveRecordの代表的なメソッド

ここでは、以下のモデルを例にActiveRecordの代表的なメソッドを簡潔に説明していきます。

`モデル User:ユーザー`

|field名|名称|型|
|:--|:--|:--|
|id|ID|integer|
|name|名前|string|
|mail_address|メールアドレス|string|

`ActiveRecordの代表的なメソッド一覧`  
※表の発行SQLは、わかりやすさのため、テーブル名は省略してカラム名のみ記述しています。

|メソッド|説明|使用例|発行SQL
|:--|:--|:--|:--
|all|全件取得(全カラム)|User.all|SELECT * FROM users
|select|全件取得(カラム指定)|User.select(:name)<br>User.select('name,mail_address')|SELECT name FROM users<br>SELECT name,mail_address FROM users
|find|検索(id指定)|User.find(1)|SELECT * FROM users WHERE id = 1
|find_by|検索(条件指定)|User.find_by(id:1)<br>User.find_by('id > 1')|SELECT \* FROM users WHERE id = 1 LIMIT 1<br>SELECT * FROM users WHERE id > 1 LIMIT 1|
|where|検索(条件指定)|User.where(id:1)<br>User.where('id > 1')|SELECT \* FROM users WHERE id = 1<br>SELECT * FROM users WHERE id > 1
|first|最初のデータをとる|User.first<br>User.first(2)|SELECT \* FROM users ORDER BY id ASC LIMIT 1<br>SELECT \* FROM users ORDER BY id ASC LIMIT 2
|last|最後のデータをとる|User.last<br>User.last(2)|SELECT \* FROM users ORDER BY id DESC LIMIT 1<br>SELECT * FROM users ORDER BY id DESC LIMIT 2
|order|ソート|User.order(:name)<br>User.order(name: :DESC)|SELECT \* FROM users ORDER BY name ASC<br>SELECT \* FROM users ORDER BY name DESC
|limit|制限|User.limit(2)|SELECT * FROM users LIMIT 2

`各メソッドの詳細`

- all
  - レコードを全件取得します
- select
  - カラムを指定し、レコードを取得します。引数の値がカラムとなります。
- find
  - 指定したidのレコードを取得します。引数の値が指定するidとなります。
  - findは、該当するデータが見つからない場合は例外（RecordNotFound）が発生します。
- find_by
  - 特定のカラムの条件を指定し、該当する1件を取得します。引数の値が条件となります。
  - find_byは該当するデータが見つからない場合は、nilを返します。
- where
  - 特定のカラムの条件を指定し、該当する全件を取得します。引数の値が条件となります。
  - whereは、該当するデータが見つからない場合は空の`ActiveRecord::Relation`を返します。
- first
  - レコードの最初の1件を取得します。引数を渡すと最初のn件と指定することもできます。
- last
  - レコードの最後の1件を取得します。引数を渡すと最後のn件と指定することもできます。
- order
  - レコードを引数に指定したカラムで並び変えます。デフォルトの並び順はASC(昇順)になっています。
  - 降順で並び変える場合は`User.order(name: :DESC)`とします。
- limit
  - 特定のレコード件数を取得します。引数の値が最大取得行数となります。

`etc`
- ActiveRecord::Relationについて
  - `ActiveRecord::Relation`とは、モデルオブジェクトのコレクションです。  
  `ActiveRecord::Relation`を返す場合は、メソッドチェーンが可能ですので、  
  例えばwhereに続いてさらにActiveRecordのメソッドを使用する事ができます。  
  ここでは詳細を説明しませんので、気になる場合は調べてみましょう。

- ?の使い方
  - 条件に変数を使用したい場合等に、?(プレースホルダ)を使用します。  
  変数でなくても、直接値を指定することも可能です。  

  ```rb
  name = "test"
  User.where("name = ?", name)
  #SELECT  "users".* FROM "users" WHERE (name = 'test')

  User.where("name = ?", 'test2')
  #SELECT  "users".* FROM "users" WHERE (name = 'test2')
  ```

### 6.1.5 例題

先生と授業(科目)のテーブルを作成し、先生と授業の多対多で関連付けしていきます。
先生は複数の授業(科目)を担当し、授業(科目)からも複数の先生が受け持っているという多対多の関連付けとして実装します。
データベース構成は以下の通りとします。

Teacher : 先生テーブル

|field名|名称|型|
|:--|:--|:--|
|name|名前|string|

Lesson : 授業テーブル

|field名|名称|型|
|:--|:--|:--|
|name|授業名|string|

TeacherLesson : 中間テーブル

|field名|名称|型|
|:--|:--|:--|
|teacher_id|先生|references|
|lesson_id|授業|references|  

![画像](images/06-3.png)

#### ①　アプリケーションの作成

まずは、例題用のRailsアプリケーションを作成します。

```sh
$ rails new teacher_sample
```

#### ②　Teacherモデルの作成

次に必要なモデルを作成してきます。  
今回はCRUD操作をしないので`rails g model`でモデルを作成します。  

```sh
$ rails g model Teacher name:string
```

#### ③　Lessonモデルの作成

```sh
$ rails g model Lesson name:string
```

#### ③　TeacherLessonモデルの作成

中間テーブルとなるモデルです。
teacherとlessonを参照するように設定して、モデルを生成します。

```sh
$ rails g model TeacherLesson teacher:references lesson:references
```
データ型を`references`にすることで中間テーブルで自動的に関連付けを定義してくれます。  
teacher、lessonとteacher_lessonのモデルが作成できたので、テーブルを作成するためにマイグレーションも実行しましょう。

```sh
$ rails db:migrate
```

各モデルの関係を設定するために、以下の内容を追記してください。  
has_many :throughは、teacher_lessonをショートカットして、teacherもしくはlessonを参照できるようにします。

```rb
# app/models/teacher.rb

class Teacher < ApplicationRecord
  has_many :teacher_lessons
  has_many :lessons, through: :teacher_lessons
end
```

```rb
# app/models/lesson.rb

class Lesson < ApplicationRecord
  has_many :teacher_lessons
  has_many :teachers, through: :teacher_lessons
end
```

teacher_lessonモデルはteacherとlessonを参照するように生成したため、既に下記のソースコードとなっています。

```rb
# app/models/teacher_lesson.rb

class TeacherLesson < ApplicationRecord
  belongs_to :teacher
  belongs_to :lesson
end
```

### 6.1.6 問題

今回のECサイトのデータベース構成は、以下のようにします。  
この構成通りに、モデルを作成してみましょう。BookとTagはscaffold、Taggingはmodelで作成しましょう。
また、各モデルの関係を設定しましょう。本と商品は多対多の関係になることに注意して下さい。  


アプリケーション名：ec_site  
Book : 本 テーブル

|field名|名称|型|
|:--|:--|:--|
|title|タイトル|string|
|author|著者|string|
|published_on|出版日|date|
|showing|商品表示|boolean|
|price|価格|integer|

Tag : 商品タグ テーブル

|field名|名称|型|
|:--|:--|:--|
|name|タグ名|string|

Tagging : タグ付け テーブル

|field名|名称|型|
|:--|:--|:--|
|book_id|本|references|
|tag_id|商品タグ|references|


### 6.1.7 練習
以下のように注文テーブル、商品テーブル、ユーザテーブルが定義されているとします。
ここで注文テーブルと商品テーブルの関係に注目すると、注文番号ひとつに対して複数の商品IDが紐づいています。
逆に商品IDひとつに対しても複数の注文番号が紐づいています。
つまり、注文番号と商品IDは多対多の関係になっているといえます。

中間テーブルを作成して、注文テーブルと商品テーブル間の多対多の関係を解消してみましょう。

注文テーブル
| 注文番号 | 注文日 | ユーザID | 商品ID | 数量 |
| -------- | ------ | ----- | ------ | ---- |
| 1 | 2024/4/5	| Y000A	| I000A	| 1 |
| 2 | 2024/5/7	| Y000B	| I000A	| 2 |
| 2 | 2024/5/7	| Y000B	| I000B	| 1 |
| 3 | 2024/6/1	| Y000C	| I000A	| 3 |
| 3 | 2024/6/1	| Y000C	| I000B	| 2 |
| 3 | 2024/6/1	| Y000C	| I000C	| 1 |

商品テーブル
| 商品ID | 商品名 | 単価 |
| ----- | ------- | --- |
| I000A | 商品名A | 100 |
| I000B | 商品名B | 200 |
| I000C	| 商品名C | 300 |

ユーザテーブル
| ユーザID | ユーザ名 |
| ----- | ------- |
| Y000A | ユーザA |
| Y000B | ユーザB |
| Y000C	| ユーザC |

