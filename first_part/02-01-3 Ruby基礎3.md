####	(10)　__クラス__  
オブジェクト指向プログラミングにおいて重要な概念の1つです。クラスは、オブジェクト(インスタンス)の設計図やテンプレートのようなものであり、それに基づいて実際のオブジェクトが生成されます。  
オブジェクト(インスタンス)には属性(データ)や振る舞い(メソッド)が定義されています。  
それらをまとめた設計図のようなものをクラスと言います。これらを実体化させることでようやくインスタンスとして扱うことが出来ます。  

#####	(10)-1　定義  
・クラス名は最初の文字を大文字（定数と同じ）にする  
・原則キャメルケース(つながりを大文字)にする  
```rb
# class クラス名
#   クラスの内容
# end

class SampleClass
	def hoge
	end
end
```

クラスとそのインスタンスを理解するために、`Person`クラスを例にしてみましょう。  
```rb
class Person
  # インスタンス変数
  attr_accessor :name, :age

  # コンストラクタ（初期化メソッド）
  def initialize(name, age)
    @name = name
    @age = age
  end

  # メソッド
  def introduce
    puts "Hi, I'm #{@name} and I'm #{@age} years old."
  end
end
```

このクラスには`name`と`age`という2つの属性(インスタンス変数)があります。また、`initialize`メソッドはインスタンスが作成される際に呼び出され、`name`と`age`を設定します。さらに、`introduce`メソッドは、その人物の情報を表示するためのメソッドです。  

では実際にどのようにインスタンスを生成し、インスタンスからメソッドを呼び出すのか確認していきましょう。  

```rb
# Personクラスのインスタンス生成
person1 = Person.new("Alice", 30)
person2 = Person.new("Bob", 25)

# インスタンスメソッドの呼び出し
person1.introduce
person2.introduce
```

`Person`クラスが設計図であり、`person1`や`person2`のような具体的な人物はその設計図に基づいて作成されたインスタンスです。これにより、同じ属性や振る舞いを持つ複数の人物を簡単に作成することができます。  


#####	(10)-2　インスタンスの生成  
クラスをもとにして実体を作成します。  
・`new`メソッドを使用することでインスタンスを生成できる  
・`initialize`メソッドを定義しておくと、インスタンスを生成した時に自動で処理される  
・生成したインスタンスはそれぞれが独立している  
```rb
class SampleClass
	def initialize
		puts "create!"
	end

	def hoge
	end
end

sample = SampleClass.new  #=> create!
```
#####	(10)-3　インスタンス変数・クラス変数  
#####	①　インスタンス変数  
・インスタンスメソッドからのみ参照することが出来る(クラス内のどのメソッドからも参照できますが、通常は外部からは直接アクセスできない)  
・インスタンスに紐付いているため、他のインスタンスの変数には干渉しない(インスタンスごとに異なる値を持つことができる)  
・インスタンス変数は未定義であっても参照できる（nilが返ってくる）  
```rb
class Foo
	# initializeメソッドから参照　=> OK
	def initialize(obj)
		# @varがインスタンス変数
		@var = obj
		p "#{@var} at initialize"
	end

	# インスタンスメソッドから参照 => OK
	def xxx
		p "#{@var} at xxx"
	end

	# クラスメソッドから参照 => NG
	# 全体ではなく実体化した個体に紐づいている
	def self.yyy
		p "#{@var} at yyy"
	end
end

foo = Foo.new("foo")        #=> "foo at initialize"
foo2 = Foo.new("foo2")      #=> "foo2 at initialize"

foo.xxx                     #=> "foo at xxx"
foo2.xxx                    #=> "foo2 at xxx"

Foo.yyy                     #=> nil
```

__【attr_accessor】__  
インスタンス変数を`attr_accessor`(アトリビュートアクセサー)で定義しています。これは本来インスタンス変数は外部から直接参照できません。  
実際にアクセスしようとするとエラーになります。  

```rb
class Person
  def initialize(name, age)
    @name = name
    @age = age
  end
end

person = Person.new("Cameron", 20)
puts person.name
puts person.age

person.name = "Daniel"
person.age = 23
```

これには、オブジェクト指向における`カプセル化`という概念が影響しています。  
`カプセル化`とはオブジェクト内部のデータを隠蔽し、外部からの直接アクセスを制限することです。プライベートメソッドなどもカプセル化の一形態として扱われます。  
外部から直接的なアクセスを許可してしまうと、オブジェクトの内部構造が外部に露呈され、それによってオブジェクトの状態が不安定になったり、意図しない値が設定されたりする可能性が高まります。  

これらを解決するのがゲッターメソッドとセッターメソッドです。  

```rb
class Person
  def initialize(name, age)
    @name = name
    @age = age
  end

  # ゲッター（getter）
  def name
    @name
  end

  def age
    @age
  end

  # セッター（setter）
  def name=(new_name)
    @name = new_name
  end

  def age=(new_age)
    @age = new_age
  end
end

person = Person.new("Cameron", 20)
puts person.name
puts person.age

person.name = "Daniel"
person.age = 23
puts person.name
puts person.age
```

`attr_accessor`を使うことでこのゲッターとセッターをひとまとめにすることができます。  
```rb
class Person
  attr_accessor :name, :age

  def initialize(name, age)
    @name = name
    @age = age
  end
end
```

#####	②　クラス変数  
・インスタンスメソッド、クラスメソッド、クラス定義内で参照出来る  
・クラス全体で共有される(そのクラスの全てのインスタンスが同じ値を共有する)  
```rb
class Foo
	# クラス内ならどこでも定義可能だが、クラス定義内に書くことが多い
	@@var = 0

	# インスタンスメソッドから参照 => OK
	def xxx
		@@var += 1
		p @@var
	end

	# クラスメソッドから参照 => OK
	def self.yyy
		@@var += 1
		p @@var
	end
end

foo = Foo.new

# 同一インスタンス内で値は共有される
foo.xxx        #=> 1
foo.xxx        #=> 2

# インスタンスが異なっても値は共有されている
foo2 = Foo.new
foo2.xxx       #=> 3

# クラスメソッドからも参照可能で値も共有されている
Foo.yyy        #=> 4
```

####	(10)-4　継承  
#####	①　クラスの継承について  
・Rubyのクラスは単一継承である  
・継承元をスーパークラス、継承先をサブクラスと呼ぶ  
・継承するクラスを省略した場合は、Objectクラスが継承される  
```rb
# 動物全般に関するクラス
# 共通する処理などをまとめて定義しておく
class Animal
end

# 犬特有のクラス
class Dog < Animal
end

# 猫特有のクラス
class Cat < Animal
end
```

#####	②　継承されるもの  
・インスタンスメソッド  
・クラスメソッド  
・クラス変数  
・定数  
```rb
class Animal
  @@count = 0
  CONSTANT_VALUE = 100

  def self.count
    @@count
  end
end

class Dog < Animal
end

puts Dog.count  # 0
puts Dog::CONSTANT_VALUE  # 100
```
#####	③　継承されないもの  
・インスタンス変数  
```rb
class Animal
  def initialize(name)
    @name = name
  end
end

class Dog < Animal
  def show_name
    puts @name  # スーパークラスのインスタンス変数にはアクセスできない
  end
end
```
			
####	(11)　__モジュール__  
#####	(11)-1　モジュールについて  
モジュールにはメソッドや定数をまとめておくことが出来ます。  
クラスと似た部分がありますが、モジュールはクラスと違い、インスタンスを生成することが出来ません。  
また、クラスのような継承も出来ないようになっています。  

その代わりに、`mix-in`と呼ばれる機能（継承方法の一種）があり、  
他のクラスにモジュールの内容を取り込み、その内容をクラス内に定義することが出来ます。  
クラス間にまたがっている共通処理をまとめておいて、必要なクラスでmix-inすると、  
コードの重複等を防ぎ綺麗に整理することが出来ます。  

他にも、単純に名前空間として利用されている場合もあります。  
これによって、コードを見た時に内容やその目的を一目で把握することが出来るようになります。  

##### (11)-2　定義  
・モジュール名は最初の文字を大文字（定数と同じ）にする  
・原則CamelCaseにする  
```rb
# module モジュール名
#   モジュールの内容
# end

module Sample
	def hoge
	end
end
```
##### (11)-3　mix-in  
・mix-inする時は、`include モジュール名`で内容を取り込むことが出来る。  
```rb
# 取り込みたいクラス内で include モジュール名

module Sample
	def to_answer(answer)
		puts "答えは#{answer}です"
	end
end

class Foo
	include Sample
end

foo = Foo.new
foo.to_answer(8)  #=> 答えは8です
```

__【問題】__  
1. 次の`Calculator`クラスを定義してください。`Calculator`クラスは次の属性とメソッドを持ちます：
- 属性:
	- `name`：計算機の名前(文字列)
- メソッド:
	- `add(a, b)`：与えられた2つの数`a`と`b`を足してその結果を返します。
	- `subtract(a, b)`：与えられた2つの数`a`と`b`を引いてその結果を返します。

2. `Calculator`クラスのインスタンスを作成し、`add`メソッドと`subtract`メソッドを使って計算を行ってください。

3. 以下の`Greeting`モジュールを定義してください。`Greeting`モジュールは`greet`メソッドを持ち、引数として受け取った名前に対してあいさつのメッセージを返します。

4. `Greeting`モジュールを``Person`クラスに`include`して、`Person`クラスのインスタンスに対してあいさつの機能を追加してください。

5. 以下の`Logger`モジュールを定義してください。`Logger`モジュールは`log`メソッドを持ち、引数として受け取ったメッセージをログとして表示します。

6. `Logger`モジュールを`EmailSender`クラスに`include`して、`EmailSender`クラスのインスタンスに対してログを記録する機能を追加してください。  


__【解答】__  
1. 解答例
```rb
class Calculator
  attr_accessor :name

  def initialize(name)
    @name = name
  end

  def add(a, b)
    a + b
  end

  def subtract(a, b)
    a - b
  end
end

```

2. 解答例
```rb
calculator = Calculator.new("SimpleCalculator")
puts calculator.add(5, 3)       #=> 8
puts calculator.subtract(10, 4) #=> 6
```
3. 解答例
```rb
module Greeting
  def greet(name)
    "Hello, #{name}!"
  end
end
```

4. 解答例
```rb
class Person
  include Greeting

  attr_accessor :name

  def initialize(name)
    @name = name
  end
end

person = Person.new("Alice")
puts person.greet(person.name)  #=> Hello, Alice!
```

5. 解答例
```rb
module Logger
  def log(message)
    puts "[LOG] #{message}"
  end
end
```

6. 解答例
```rb
class EmailSender
  include Logger

  def send_email(to, subject, body)
    log("Sending email to: #{to}, Subject: #{subject}, Body: #{body}")
  end
end

email_sender = EmailSender.new
email_sender.send_email("example@example.com", "Test Email", "This is a test email.")
```
